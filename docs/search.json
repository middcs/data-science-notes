[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Data Science",
    "section": "",
    "text": "Welcome\nThis is a set of notes developed for an undergraduate course in data science. The target audience for these notes are students who have completed a first course in either programming or data science.\n© Michael Linderman and Phil Chodrow, 2025",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#pedagogical-features",
    "href": "index.html#pedagogical-features",
    "title": "Applied Data Science",
    "section": "Pedagogical Features",
    "text": "Pedagogical Features\nThese notes are explicitly designed for undergraduate instruction. For this reason:\n\nComputational examples are integrated into the text and shown throughout.\nLive versions of lecture notes are supplied via Google Colab, with certain code components removed. The purpose is to facilitate live-coding in lectures.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#use-and-reuse",
    "href": "index.html#use-and-reuse",
    "title": "Applied Data Science",
    "section": "Use and Reuse",
    "text": "Use and Reuse\nThese notes were written by Michael Linderman and Phil Chodrow for the course CSCI 1010: Applied Data Science at Middlebury College. All are welcome to use them for educational purposes. Attribution is appreciated but not expected.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#source-texts",
    "href": "index.html#source-texts",
    "title": "Applied Data Science",
    "section": "Source Texts",
    "text": "Source Texts\nWe rely a lot on Vanderplas (2016).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Applied Data Science",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThis site was generated using the Quarto publishing system. It is hosted on GitHub and published via GitHub Pages. Google Colab provides free access to interactive Python environments for live coding.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Applied Data Science",
    "section": "References",
    "text": "References\n\n\n\n\nVanderplas, Jacob T. 2016. Python Data Science Handbook: Essential Tools for Working with Data. First edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "chapters/01-data-and-models.html",
    "href": "chapters/01-data-and-models.html",
    "title": "1  Data, Patterns, and Models",
    "section": "",
    "text": "Supervised Learning\nBroadly, machine learning is the science and practice of building algorithms that learn patterns from data. Here are two synthetic examples of data in which there is some kind visually clear pattern in the data. In the first example (Figure 1.1 (a)), we can see that there is a relationship between two quantitative variables, \\(x\\) and \\(y\\). If someone told is the value of \\(x\\), then we would likely be able to make a reasonable prediction about the value of the number \\(y\\). This is an example of a regression task. In the second example (Figure 1.1 (b)), we can observe a relation between the location of each data point in 2d space and a color, which could represent a category or class. If someone told us the location of the point in 2d space, we would likely be able to say which of the two classes it belonged to. This is an example of a classification task.\nIn examples like these, it’s often possible for us to just use our eyes and spatial reasoning in order to make a reasonable prediction.\nHow do we encode this knowledge mathematically, in a way that a computer can understand and use? In each of the two cases, we can express the pattern in the data as a mathematical function.\nOur focus in these notes is almost exclusively on supervised learning. In supervised learning, we are able to view some attributes or features of a data point, which we call predictors. Traditionally, we collect these attributes into a vector called \\(\\mathbf{x}\\). Each data point then has a target, which could be either a scalar number or a categorical label. Traditionally, the target is named \\(y\\). We aim to predict the target based on the predictors using a model, which is a function \\(f\\). The result of applying the model \\(f\\) to the predictors \\(\\mathbf{x}\\) is our prediction or predicted target \\(f(\\mathbf{x})\\), to which we often give the name \\(\\hat{y}\\). Our goal is to choose \\(f\\) such that the predicted target \\(\\hat{y}\\) is equal to, or at least close to, the true target \\(y\\). We could summarize this with the heuristic statement:\n\\[\n\\begin{aligned}\n    \\text{``}f(\\mathbf{x}) = \\hat{y} \\approx y\\;.\\text{''}\n\\end{aligned}\n\\]\nHow we interpret this heuristic statement depends on context. In regression problems, this statement typically means “\\(\\hat{y}\\) is usually close to \\(y\\)”, while in classification problems this statement usually means that “\\(\\hat{y} = y\\) exactly most or all of the time.”\nIn our regression example from above, we can think of a function \\(f:\\mathbb{R}\\rightarrow \\mathbb{R}\\) that maps the predictor \\(x\\) to the prediction \\(\\hat{y}\\). In the case of classification, things are a little more complicated. Although the function \\(g(x_1) = 1 - x_1\\) is visually very relevant, that function is not itself the model we use for prediction. Instead, our prediction function should return one classification label for points on one side of the line defined by that function, and a different label for points on the other side. If we say that blue points are labeled \\(0\\) and brown points are labeled \\(1\\), then our predictor function can be written \\(f:\\mathbb{R}^2 \\rightarrow \\{0, 1\\}\\), and it could be written heuristically like this:\n\\[\n\\begin{aligned}\n    f(\\mathbf{x}) &= \\mathbb{1}[\\mathbf{x} \\text{ is above the line}] \\\\\n                  &= \\mathbb{1}[x_1 + x_2 \\geq 1] \\\\\n                  &= \\mathbb{1}[x_1 + x_2 - 1\\geq 0]\\;.\n\\end{aligned}\n\\]\nThis last expression looks a little clunky, but we will soon find out that it is the easiest one to generalize to an advanced setting.\n© Michael Linderman and Phil Chodrow, 2025",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data, Patterns, and Models</span>"
    ]
  },
  {
    "objectID": "chapters/01-data-and-models.html#supervised-learning",
    "href": "chapters/01-data-and-models.html#supervised-learning",
    "title": "1  Data, Patterns, and Models",
    "section": "",
    "text": "Here, \\(\\mathbb{1}\\) is the indicator function which is equal to 1 if its argument is true and 0 otherwise. Formally,\n\\[\n\\begin{aligned}\n    \\mathbb{1}[P] = \\begin{cases}\n        1 &\\quad P \\text{ is true} \\\\\n        0 &\\quad P \\text{ is false.}\n        \\end{cases}\n\\end{aligned}\n\\]",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Data, Patterns, and Models</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html",
    "href": "chapters/02-black-box-classification.html",
    "title": "2  Classification as a Black Box",
    "section": "",
    "text": "Classifying the Palmer Penguins\nIn these notes, we’ll make a lightning tour through the “standard workflow” for users of predictive machine learning technologies. Our focus will be on out-of-the-box Python tools for acquiring, visualizing, and analyzing tabular data sets.\nWe’re going to move pretty quickly through some big topics in practical data science: acquiring data, data visualization, data manipulation, and prediction using the Scikit-Learn package. Throughout these notes, I’ve sprinkled references to the Python Data Science Handbook (Vanderplas 2016), which treats many of these practical considerations in much greater detail.\nOur data set for these notes is Palmer Penguins. This data set contains physiological measurements and species labels for several populations of Adelie, Chinstrap, and Gentoo penguins.\nLet’s go ahead and acquire the data.\nimport warnings\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nnp.set_printoptions(precision = 3)\nurl = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/palmer-penguins.csv\"\ndf = pd.read_csv(url)\nLet’s take a look:\ndf.head() # first 5 rows\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0708\n1\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN1A1\nYes\n11/11/07\n39.1\n18.7\n181.0\n3750.0\nMALE\nNaN\nNaN\nNot enough blood for isotopes.\n\n\n1\nPAL0708\n2\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN1A2\nYes\n11/11/07\n39.5\n17.4\n186.0\n3800.0\nFEMALE\n8.94956\n-24.69454\nNaN\n\n\n2\nPAL0708\n3\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN2A1\nYes\n11/16/07\n40.3\n18.0\n195.0\n3250.0\nFEMALE\n8.36821\n-25.33302\nNaN\n\n\n3\nPAL0708\n4\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN2A2\nYes\n11/16/07\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nAdult not sampled.\n\n\n4\nPAL0708\n5\nAdelie Penguin (Pygoscelis adeliae)\nAnvers\nTorgersen\nAdult, 1 Egg Stage\nN3A1\nYes\n11/16/07\n36.7\n19.3\n193.0\n3450.0\nFEMALE\n8.76651\n-25.32426\nNaN\nIt’s always useful to get acquainted with the “basics” of the data. For example, how many rows and columns do we have?\ndf.shape # (rows, columns)\n\n(344, 17)\ndf.dtypes \n\nstudyName               object\nSample Number            int64\nSpecies                 object\nRegion                  object\nIsland                  object\nStage                   object\nIndividual ID           object\nClutch Completion       object\nDate Egg                object\nCulmen Length (mm)     float64\nCulmen Depth (mm)      float64\nFlipper Length (mm)    float64\nBody Mass (g)          float64\nSex                     object\nDelta 15 N (o/oo)      float64\nDelta 13 C (o/oo)      float64\nComments                object\ndtype: object\nHere’s the question we’ll ask today about this data set:\n© Michael Linderman and Phil Chodrow, 2025",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#classifying-the-palmer-penguins",
    "href": "chapters/02-black-box-classification.html#classifying-the-palmer-penguins",
    "title": "2  Classification as a Black Box",
    "section": "",
    "text": "Image source: @allisonhorst\n\n\n\nThe Palmer Penguins data was originally collected by Gorman, Williams, and Fraser (2014) and was nicely packaged and released for use in the data science community by Horst, Hill, and Gorman (2020). You can find a very concise summary of the main workflow using a similar data set in Vanderplas (2016).\n\n\n\n\n The df variable holds a pandas.DataFrame object. You can think of a data frame as a table of data with a variety of useful behaviors for data manipulation and visualization.You can learn much more about the capabilities of pandas.DataFrame objects in Chapter 3 of Vanderplas (2016)\n\n\n\n\nWhat are the data types of the columns? str columns are represented with the generic object in Pandas.\n\n\n\nGiven some physiological measurements of a penguin, can we reliably infer its species?",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#data-preparation",
    "href": "chapters/02-black-box-classification.html#data-preparation",
    "title": "2  Classification as a Black Box",
    "section": "Data Preparation",
    "text": "Data Preparation\nWe can select our desired columns from the data frame, operate on them, and make assignments to them using the data-frame-as-dictionary paradigm explored in Vanderplas (2016).\nIn applied data science, at least 80% of the work is typically spent acquiring and preparing data. Here, we’re going to do some simple data preparation directed by our question. It’s going to be convenient to shorten the Species column for each penguin. Furthermore, for visualization purposes today we are going to focus on the Culmen Length (mm) and Culmen Depth (mm) columns.\n\n# use only these three columns\ndf = df[[\"Culmen Length (mm)\", \"Culmen Depth (mm)\", \"Species\"]] \n\n# remove any rows that have missing data in any of the selected columns. \ndf = df.dropna()\n\n# slightly advanced syntax: \n# replace the column with the first word in each entry\ndf[\"Species\"] = df[\"Species\"].str.split().str.get(0)\n\nLet’s take a look at what we’ve done so far:\n\ndf.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nSpecies\n\n\n\n\n0\n39.1\n18.7\nAdelie\n\n\n1\n39.5\n17.4\nAdelie\n\n\n2\n40.3\n18.0\nAdelie\n\n\n4\n36.7\n19.3\nAdelie\n\n\n5\n39.3\n20.6\nAdelie\n\n\n\n\n\n\n\nAs another preprocessing step, we are going to add transformed labels represented as integers.\n\n# for later: assign an integer to each species\nfrom sklearn.preprocessing import LabelEncoder\n\nle = LabelEncoder()\ndf[\"species_label\"] = le.fit_transform(df[\"Species\"])\n\nfor i, c in enumerate(le.classes_):\n    print(f\"Class number {i} represents {c} penguins.\")\n\nClass number 0 represents Adelie penguins.\nClass number 1 represents Chinstrap penguins.\nClass number 2 represents Gentoo penguins.\n\n\nNow our data looks like this:\n\ndf.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nSpecies\nspecies_label\n\n\n\n\n0\n39.1\n18.7\nAdelie\n0\n\n\n1\n39.5\n17.4\nAdelie\n0\n\n\n2\n40.3\n18.0\nAdelie\n0\n\n\n4\n36.7\n19.3\nAdelie\n0\n\n\n5\n39.3\n20.6\nAdelie\n0\n\n\n\n\n\n\n\n\nTrain-Test Split\nWhen designing predictive models, it’s important to evaluate them in a context that simulates the prediction application as accurately as possible. One important way we do this is by performing a train-test split. We keep most of the data as training data which we’ll use to design the model. We’ll hold out a bit of the data as testing data, which we’ll treat as unseen and only use once we are ready to evaluate our final design. The testing data simulates the idea of “new, unseen data” – exactly the kind of data on which it would be useful for us to make predictions!\n\nfrom sklearn.model_selection import train_test_split\n\ndf_train, df_test = train_test_split(df, test_size = 0.2)\n\nLet’s check the size of our two split data sets:\n\ndf_train.shape, df_test.shape\n\n((273, 4), (69, 4))\n\n\nNow we’re going to forget that df_test exists for a while. Instead, we’ll turn our attention to analysis, visualization and modeling.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#data-analysis-and-visualization",
    "href": "chapters/02-black-box-classification.html#data-analysis-and-visualization",
    "title": "2  Classification as a Black Box",
    "section": "Data Analysis and Visualization",
    "text": "Data Analysis and Visualization\nAs a first step, it’s useful to understand how many of each species there are in the training data:\nThis is an example of a “split-apply-combine” operation (Wickham 2011). We split the dataframe into three groups depending on the species label, apply an operation (in this case, computing the number of rows), and then combine the results into a single object. Pandas implements split-apply-combine primarily through the groupby method and several associated functions. There are some nice examples of split-apply-combine in Pandas in Vanderplas (2016).\n\ndf_train.groupby(\"Species\").size()\n\nSpecies\nAdelie       120\nChinstrap     54\nGentoo        99\ndtype: int64\n\n\nThere are more Adelie penguins than Chintraps or Gentoos in this data set. Here are the proportions:\n\ndf_train.groupby(\"Species\").size() / df_train.shape[0] # divide by total rows\n\nSpecies\nAdelie       0.439560\nChinstrap    0.197802\nGentoo       0.362637\ndtype: float64\n\n\nSo, over 40% of the penguins in the data are Adelie penguins. One important consequence of this proportion is the base rate of the classification problem. The base rate refers to how well we could perform at prediction if we did not use any kind of predictive modeling, but instead simply predicted the most common class for every penguin. Here, if we always predicted “Adelie” for the species, we’d expect to be right more than 40% of the time. So, a minimal expectation of anything fancier we do is that it should be correct much more than 40% of the time.\nNow let’s take a look at our (training) data and see whether our chosen columns look like they have a chance of predicting the penguin species. We’ll show the plot both without and with the species labels.\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nfig, ax = plt.subplots(1, 2, figsize = (8, 3.5))\n\np1 = sns.scatterplot(df_train, x = \"Culmen Length (mm)\", y = \"Culmen Depth (mm)\", ax = ax[0], color = \"darkgrey\")\np2 = sns.scatterplot(df_train, x = \"Culmen Length (mm)\", y = \"Culmen Depth (mm)\", hue = \"Species\", style = \"Species\", ax = ax[1])\n\n\n\n\nThese plots are generated using the Seaborn library for Python. Seaborn is a high-level wrapper around the classical matplotlib library for data visualization. Although Matplotlib is very flexible, Seaborn is optimized for visualizing data contained in Pandas data frames. You can find many examples of creating Seaborn plots in the official gallery, and many tips and examples for matplotlib in Vanderplas (2016).\n\n\n\n\nWe can think of the lefthand side as “what the model will see:” just physiological measurements with no labels. On the right we can see the data with its species labels included. We can see that the species are divided into clusters: Adelie penguins have measurements which tend to be similar to other Adelies; Chinstraps are similar to other Chinstraps, etc.\nThis pattern is promising! The approximate separation of the species suggests that a machine learning model which predicts the species label from these measurements is likely to be able to beat the base rate.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#modeling-and-model-selection",
    "href": "chapters/02-black-box-classification.html#modeling-and-model-selection",
    "title": "2  Classification as a Black Box",
    "section": "Modeling and Model Selection",
    "text": "Modeling and Model Selection\nLet’s go ahead and fit some models! We’re going to fit two models that are pre-implemented in the package scikit-learn. For now, you can think of these models as black-box algorithms that accept predictor variables as inputs and return a predicted target as an output. In our case, the predictor variables are the culmen length and culmen depth columns, while the target we are attempting to predict is the species. Later on, we’ll learn more about how some of these models actually work.\n\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC # support vector classifier\nfrom mlxtend.plotting import plot_decision_regions # for visualization later\n\nIt’s convenient to split our data into predictors \\(\\mathbf{X}\\) and targets \\(\\mathbf{y}\\). We need to do this once for each of the training and test sets.\n\npredictor_cols = [\"Culmen Length (mm)\", \"Culmen Depth (mm)\"]\ntarget_col = \"species_label\"\n\nX_train = df_train[predictor_cols]\ny_train = df_train[target_col]\n\nX_test = df_test[predictor_cols]\ny_test = df_test[target_col]\n\nLet’s take a quick look at X_train\n\nX_train\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\n\n\n\n\n114\n39.6\n20.7\n\n\n140\n40.2\n17.1\n\n\n315\n50.8\n15.7\n\n\n185\n51.0\n18.8\n\n\n192\n49.0\n19.5\n\n\n...\n...\n...\n\n\n6\n38.9\n17.8\n\n\n29\n40.5\n18.9\n\n\n266\n45.5\n13.9\n\n\n1\n39.5\n17.4\n\n\n81\n42.9\n17.6\n\n\n\n\n273 rows × 2 columns\n\n\n\nWe’ll go in-depth on logistic regression later in this course.\nNow we’re ready to fit our first machine learning model. Let’s try logistic regression! In the Scikit-learn API, we first need to instantiate the LogisticRegression() class, and then call the fit() method of this class on the training predictors and targets.\n\nLR = LogisticRegression()\nm = LR.fit(X_train, y_train)\n\nSo, uh, did it work? The LogisticRegression() class includes a handy method to compute the accuracy of the classifier:\n\nLR.score(X_train, y_train)\n\n0.9597069597069597\n\n\nWow! Much better than the base rate. Note that this is the accuracy on the training data. In theory, accuracy on the test data could look very different.\nA useful way to visualize models with two numerical predictors is via decision regions. Each region describes the set of possible measurements that would result in a given classification.\nYou can unfold this code to see a simple implementation of a function for plotting decision regions which wraps the plot_decision_regions function of the mlxtend package.\n\n\nCode\ndef decision_regions(X, y, model, title):\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        ax = plot_decision_regions(X_train.to_numpy(), y_train.to_numpy(), clf = model, legend = 2)\n\n        handles, labels = ax.get_legend_handles_labels()\n        ax.legend(handles, \n                le.classes_, \n                framealpha=0.3, scatterpoints=1)\n\n        ax.set(xlabel = \"Culmen Length (mm)\", ylabel = \"Culmen Depth (mm)\", title = f\"{title}: Accuracy = {model.score(X, y):.3f}\")\n\ndecision_regions(X_train, y_train, LR, \"Decision Regions for Logistic Regression\")\n\n\n\n\n\n\n\n\n\nYou can learn more about how support vector machines work in Vanderplas (2016). We’ll also study these models later in the course.\nWhile we’re at it, let’s try fitting a different classifier, also supplied by Scikit-learn. This classifier is called support vector machine (SVM).\n\nSVM = SVC(gamma = 5)\nSVM.fit(X_train, y_train)\ndecision_regions(X_train, y_train, SVM, \"Decision Regions for Support Vector Machine\")\n\n\n\n\n\n\n\n\nWow! The support vector machine classifier achieved even higher accuracy on the training data. This is enabled by the greater flexibility of the SVM. Flexibility comes from a lot of places in machine learning, and generally refers to the ability of models to learn complicated decision boundaries like the ones shown here.\nBut is this increased flexibility a good thing? You might look at this predictor and think that something funny is going on. For example, shouldn’t a point on the bottom right be more likely to be a Gentoo penguin than an Adelie?…\n\nSimulating Evaluation: Cross-Validation\nNow we have two competing classification models: logistic regression and support vector machine. Which one is going to do the best job of prediction on totally new, unseen data? We could go ahead and evaluate on our test set, but for statistical reasons we need to avoid doing this until we’ve made a final choice of classifier.\nVanderplas (2016) has more on cross-validation and overfitting. We’ll confront overfitting agian many times in this course.\nIn order to make an assessment, we can simulate the process of fitting the model and evaluating on “test” data by witholding parts of our training data to use as testing. We split the data into chunks and withold each chunk, using the other chunks to train the data. This is called cross-validation, and it is illustrated in this figure:\n\n\n\nImage source: scikit-learn\n\n\nWe could do this with a janky for-loop, but the nice scikit-learn developers have implemented this for us. Here’s an example of cross-validation with 5 folds. This can take a little while, as there are actually 5 calls to model.fit() happening under the hood each time.\n\nfrom sklearn.model_selection import cross_val_score\n\nFirst let’s compute the cross-validation accuracies for logistic regression:\n\ncv_scores_LR = cross_val_score(LR, X_train, y_train, cv=5)\ncv_scores_LR\n\n/Users/philchodrow/My Drive (pchodrow@middlebury.edu)/teaching/ml-notes/env/lib/python3.10/site-packages/sklearn/linear_model/_logistic.py:465: ConvergenceWarning:\n\nlbfgs failed to converge (status=1):\nSTOP: TOTAL NO. OF ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n\n\n\narray([0.964, 1.   , 0.873, 0.944, 0.981])\n\n\nA convenient way to summarize these results is by computing the average:\n\ncv_scores_LR.mean()\n\nnp.float64(0.9524579124579124)\n\n\nLet’s compare to SVM:\n\ncv_scores_SVM = cross_val_score(SVM, X_train, y_train, cv=5)\ncv_scores_SVM.mean()\n\nnp.float64(0.8646464646464647)\n\n\nAh! It looks like our SVM classifier was indeed too flexible to do well in predicting data that it hasn’t seen before. Although the SVM had better training accuracy than the logistic regression model, it failed to generalize to the task of unseen prediction. This phenomenon is called overfitting. Dealing with overfitting is one of the fundamental modeling challenges in applied machine learning.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#model-evaluation",
    "href": "chapters/02-black-box-classification.html#model-evaluation",
    "title": "2  Classification as a Black Box",
    "section": "Model Evaluation",
    "text": "Model Evaluation\nSo far, we’ve fit a logistic regression model and a support vector machine model; compared the two on a cross-validation task; and determined that the logistic regression model is most likely to generalize. Let’s now retrain the logistic regression model on the complete training data and finally evaluate it on the test set:\n\nLR.fit(X_train,y_train) \nLR.score(X_test, y_test)\n\n0.9855072463768116\n\n\nNot bad! This is our final estimate for the accuracy of our model as a classification tool on unseen penguin data.\n\nBeyond Accuracy\nAccuracy is a simple measure of how many errors a model makes. In many applications, it’s important to understand what kind of errors the model makes, a topic which we’ll study much more when we come to decision theory in the near future. We can get a quick overview of the kinds of mistakes that a model makes by computing the confusion matrix between the true labels and predictions. This matrix cross-tabulates all the true labels with all the predicted ones.\n\nfrom sklearn.metrics import confusion_matrix\n\ny_test_pred = LR.predict(X_test)\nC = confusion_matrix(y_test, y_test_pred)\nC\n\narray([[30,  1,  0],\n       [ 0, 14,  0],\n       [ 0,  0, 24]])\n\n\nThe entry in the ith row and jth column of the confusion matrix gives the number of data points that have true label i and predicted label j from our model.\n\nfor i in range(3):\n    for j in range(3):\n        print(f\"There were {C[i,j]} {le.classes_[i]} penguin(s) who were classified as {le.classes_[j]}.\")\n\nThere were 30 Adelie penguin(s) who were classified as Adelie.\nThere were 1 Adelie penguin(s) who were classified as Chinstrap.\nThere were 0 Adelie penguin(s) who were classified as Gentoo.\nThere were 0 Chinstrap penguin(s) who were classified as Adelie.\nThere were 14 Chinstrap penguin(s) who were classified as Chinstrap.\nThere were 0 Chinstrap penguin(s) who were classified as Gentoo.\nThere were 0 Gentoo penguin(s) who were classified as Adelie.\nThere were 0 Gentoo penguin(s) who were classified as Chinstrap.\nThere were 24 Gentoo penguin(s) who were classified as Gentoo.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#recap",
    "href": "chapters/02-black-box-classification.html#recap",
    "title": "2  Classification as a Black Box",
    "section": "Recap",
    "text": "Recap\nIn these notes, we took a very quick tour of the core data science workflow. We considered a simple classification problem in which we acquired some data, cleaned it up a bit, visualized several of its features, used those features to make a predictive classification model, visualized that model, and evaluated its accuracy. Along the way, we encountered the phenomenon of overfitting: models that are too flexible will achieve remarkable accuracy on the training set but will generalize poorly to unseen data. The problem of designing models that are “flexible enough” and “in the right way” is a fundamental driving force in modern machine learning, and the deep learning revolution can be viewed as the latest paradigm for seeking appropriately flexible models.\nSo far, we haven’t attempted to understand how any of these predictive models actually work. We’ll dive into this topic soon.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/02-black-box-classification.html#references",
    "href": "chapters/02-black-box-classification.html#references",
    "title": "2  Classification as a Black Box",
    "section": "References",
    "text": "References\n\n\n\n\nGorman, Kristen B., Tony D. Williams, and William R. Fraser. 2014. “Ecological Sexual Dimorphism and Environmental Variability Within a Community of Antarctic Penguins (Genus Pygoscelis).” Edited by André Chiaradia. PLoS ONE 9 (3): e90081. https://doi.org/10.1371/journal.pone.0090081.\n\n\nHorst, Allison M, Alison Presmanes Hill, and Kristen B Gorman. 2020. “Allisonhorst/Palmerpenguins: V0.1.0.” Zenodo. https://doi.org/10.5281/ZENODO.3960218.\n\n\nVanderplas, Jacob T. 2016. Python Data Science Handbook: Essential Tools for Working with Data. First edition. Sebastopol, CA: O’Reilly Media, Inc.\n\n\nWickham, Hadley. 2011. “The Split-Apply-Combine Strategy for Data Analysis.” Journal of Statistical Software 40 (1). https://doi.org/10.18637/jss.v040.i01.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Classification as a Black Box</span>"
    ]
  },
  {
    "objectID": "chapters/20-introduction-prediction.html",
    "href": "chapters/20-introduction-prediction.html",
    "title": "3  Introducing Prediction",
    "section": "",
    "text": "Linear Regression\nIn the task of automated prediction, we aim to use a relationship between a set of input features (also called predictors or independent variables) and an output (also called a target). We use this relationship to make a prediction about what outputs would be observed from new inputs.\nFor example, suppose we have a numerical input \\(x\\) and a numerical output \\(y\\), and suppose we knew that the input \\(x\\) and the output \\(y\\) were related according to the following linear relationship: \\[\n\\begin{aligned}\ny = f(x) = 2x + 1\n\\end{aligned}\n\\]\nLet’s visualize this relationship:\nIf we knew this input-output relationship, then we could use it to make predictions for any value of \\(x\\). For example, if we observed an input value of \\(x = 0.5\\), we could predict that the corresponding output would be \\(y = 2(0.5) + 1 = 2\\):\nThe problem, however, is that nature very rarely gives us a true mathematical relationship between inputs and outputs. Instead, we get data. Rather than knowing the true relationship \\(y = f(x)\\), we instead observe a set of input-output pairs \\((x_i, y_i)\\) for \\(i = 1, \\ldots, n\\). What we are given looks much more like this:\nOur goal is to use this data to learn an approximate relationship \\(\\hat{y} = \\hat{f}(x)\\) that we can then use to make predictions for new input values.\nTechnically, the problem of learning a relationship between numerical inputs and a numerical output is called regression. We’ll consider linear regression, which assumes that the relationship between input and output is linear. In the case of a single input \\(x\\) and output \\(y\\), this means that we are trying to learn a relationship of the form:\n\\[\n\\begin{aligned}\n    y \\approx \\hat{y} = \\hat{f}(x) = wx + b\n\\end{aligned}\n\\]\nHere, \\(\\hat{y}\\) is the name that we’ll give to our model’s predicted output, which is hopefully close to the true output \\(y\\). The predicted output is a linear function of the input \\(x\\). In this function, \\(w\\) is the slope of the line and \\(b\\) is the intercept. We call \\(w\\) and \\(b\\) the model parameters. The task of fitting the model is the task of finding values of \\(w\\) and \\(b\\) that make the model’s predictions \\(\\hat{y}\\) as close as possible to the observed outputs \\(y\\) in the training data.\nLet’s construct a data frame with several candidate examples of model parameters \\(w\\) and \\(b\\):\nk_params = 5\n\nmodel_df = pd.DataFrame({\n    'w': 2*(np.random.rand(k_params) - 0.5) + 2,\n    'b': 2*(np.random.rand(k_params) - 0.5) + 1\n})\n\nmodel_df\n\n\n\n\n\n\n\n\nw\nb\n\n\n\n\n0\n1.704217\n0.934108\n\n\n1\n2.354898\n0.338754\n\n\n2\n1.911220\n0.870921\n\n\n3\n1.561539\n0.919186\n\n\n4\n2.665996\n1.971181\nEach row of this data frame corresponds to a different candidate linear model. Let’s visualize their predictions:\nfor i in range(k_params):     \n    w = model_df.loc[i, 'w']\n    b = model_df.loc[i, 'b']\n    \n    df[\"y_pred\"] = w * df[\"x\"] + b\n    sns.lineplot(data=df, x='x', y='y_pred', ax=ax, label = f'Model {i}')\n\nfig_1\n\n\n\n\n\n\n\nFigure 3.4: Predictions from several candidate linear regression models.\nEach of the models gives different predictions \\(\\hat{y}\\) given the same input \\(x\\). How do we determine which of these models is “best”? A reasonable intuition here is that a good model should make predictions \\(\\hat{y}\\) which are close to the obserevd outputs \\(y\\) on average. One way to express the idea of closeness is to consider the residuals \\(r_i = y_i - \\hat{y}_i\\), which measure the difference between the observed output \\(y_i\\) and the predicted output \\(\\hat{y}_i\\) for each data point \\(i\\):\nfig, ax = plt.subplots(figsize=(6, 4))\n\nsns.scatterplot(data=df, x='x', y='y', ax=ax, edgecolors = \"black\", facecolors='white', s=50)\n\n# example model parameters\nw = 2.1\nb = 0.9\n\ndf['y_pred'] = w * df['x'] + b\n\n# plot regression line\nx_vals = np.linspace(df['x'].min(), df['x'].max(), 200)\nax.plot(x_vals, w * x_vals + b, \n        color='black', \n        linewidth=2, \n        label=fr'Model: $\\hat{{y}}={w:.1f}x+{b:.1f}$')\n\n# draw residuals as vertical lines from observed y to predicted y\nax.vlines(df['x'], \n          df['y'], \n          df['y_pred'], \n          color='gray', \n          linestyle='--', \n          alpha=0.8, \n          linewidth=1, \n          label = \"Residuals\", \n          zorder = -10)\n\nax.legend()\n\n\n\n\n\n\n\nFigure 3.5: Residuals for a candidate linear regression model.\nLet’s quantify the idea of closeness using these residuals. The following function accepts three arguments: the model_df containing coefficients, the data df containing x and y, and a metric function that quantifies the closeness between y and predicted y_pred. The result is a column of scores computed according to metric.\ndef score_model(model_df, df, metric):\n    return model_df.apply(lambda row: metric(df[\"y\"], row['w'] * df[\"x\"] + row['b']), axis=1)\nFor example, suppose we use the mean residuals to score the candidate models from above. In this case, the model’s score, which we’ll call \\(L\\), would be:\n\\[\n\\begin{aligned}\n    L = \\frac{1}{n} \\sum_{i=1}^{n} r_i = \\frac{1}{n} \\sum_{i=1}^{n} ( \\hat{y}_i - y_i )\n\\end{aligned}\n\\]\nLet’s try it out:\ndef mean_residuals(y, y_pred):\n    return (y_pred - y).mean()\n\nmodel_df[\"mean_residuals\"] = score_model(model_df, df, mean_residuals)\nmodel_df.sort_values(\"mean_residuals\")\n\n\n\n\n\n\n\n\nw\nb\nmean_residuals\n\n\n\n\n1\n2.354898\n0.338754\n-0.453402\n\n\n3\n1.561539\n0.919186\n-0.253291\n\n\n0\n1.704217\n0.934108\n-0.169972\n\n\n2\n1.911220\n0.870921\n-0.133926\n\n\n4\n2.665996\n1.971181\n1.328160\nIf we compare the mean residuals for each model to Figure 3.4, we can see that our use of the mean residual as a scoring metric tends to prefer models that under-predict (i.e. models with negative mean residuals). That doesn’t seem to be a great idea, and doesn’t match our intuition for which of the models above best “fits” the data.\nA more standard idea is to use not the mean error, but the mean squared error (MSE) as a scoring metric. The MSE is defined as:\n\\[\n\\begin{aligned}\n    \\text{MSE} = \\frac{1}{n} \\sum_{i=1}^{n} ( \\hat{y}_i - y_i )^2\n\\end{aligned}\n\\]\nWe can implement this metric in Python as follows:\ndef mse(y, y_pred):\n    return ((y_pred - y) ** 2).mean()\nNow let’s use the MSE to score our candidate models:\nmodel_df[\"mse\"] = score_model(model_df, df, mse)\nmodel_df.sort_values(\"mse\", inplace=True)\nmodel_df\n\n\n\n\n\n\n\n\nw\nb\nmean_residuals\nmse\n\n\n\n\n2\n1.911220\n0.870921\n-0.133926\n0.056251\n\n\n0\n1.704217\n0.934108\n-0.169972\n0.075708\n\n\n3\n1.561539\n0.919186\n-0.253291\n0.121676\n\n\n1\n2.354898\n0.338754\n-0.453402\n0.253681\n\n\n4\n2.665996\n1.971181\n1.328160\n1.841772\nThe mse identifies model np.int64(2) as the best model among our candidates. Comparing to Figure 3.4 suggests that the preferred model under the MSE does indeed seem to be one that fits the data better.\n© Michael Linderman and Phil Chodrow, 2025",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introducing Prediction</span>"
    ]
  },
  {
    "objectID": "chapters/20-introduction-prediction.html#working-with-real-data-abalone-age-prediction",
    "href": "chapters/20-introduction-prediction.html#working-with-real-data-abalone-age-prediction",
    "title": "3  Introducing Prediction",
    "section": "Working With Real Data: Abalone Age Prediction",
    "text": "Working With Real Data: Abalone Age Prediction\nLet’s now try linear regression with some real data. Abalone are a type of sea snail which are often harvested for food and jewelry.\n\n\n\n\n\nSeveral red abalone, from a vendor selling them for food. Image credit: Hog Island Oyster Co. \n\n\nDetermining the age of an abalone is an important task for sustainably managing the population. The age of an abalone can be determined by counting the number of rings on its shell, but this is very time-consuming relative to measuring other physical characteristics of the abalone like its size and weight. It would be helpful if we could reliably predict the age (number of rings) of an abalone from these other physical characteristics. Let’s download a data set to help us do this:\n\nurl = \"https://raw.githubusercontent.com/middcs/data-science-notes/refs/heads/main/data/abalone/abalone.csv\"\ndf = pd.read_csv(url)\n\nThe abalone data set (Nash and Ford 1994) contains measurements for 4177 individual abalones. Here’s how the data looks: We have unscaled the numerical columns back to their original units.\n\ndf.head()\n\n\n\n\n\n\n\n\nsex\nlength (mm)\ndiameter (mm)\nheight (mm)\nwhole_weight (g)\nshucked_weight (g)\nviscera_weight (g)\nshell_weight (g)\nrings\n\n\n\n\n0\nM\n91.0\n73.0\n19.0\n102.8\n44.9\n20.2\n30.0\n15\n\n\n1\nM\n70.0\n53.0\n18.0\n45.1\n19.9\n9.7\n14.0\n7\n\n\n2\nF\n106.0\n84.0\n27.0\n135.4\n51.3\n28.3\n42.0\n9\n\n\n3\nM\n88.0\n73.0\n25.0\n103.2\n43.1\n22.8\n31.0\n10\n\n\n4\nI\n66.0\n51.0\n16.0\n41.0\n17.9\n7.9\n11.0\n7\n\n\n\n\n\n\n\nThe sex column is qualitative (Male, Female, Infant), while the other columns give numerical units. The length, diameter, and height columns are in millimeters, while the whole_weight, shucked_weight, viscera_weight, and shell_weight columns are in grams. The rings column gives the number of rings on the abalone’s shell, which is our target variable. If we take a look at a few of the numerical columns, we can see that they tend to correlate with rings, giving us hope that we can use them as predictors:\n\nsns.pairplot(df, \n             x_vars = [\"height (mm)\", \"length (mm)\", \"shell_weight (g)\"], \n             y_vars = [\"rings\"], \n             plot_kws={'alpha':0.5}, )\n\n\n\n\n\n\n\nFigure 3.6: Pairplot showing relationships between several physical characteristics of abalones and their age (number of rings).\n\n\n\n\n\nThe column whole_weight is a composite of the shucked_weight (the body of the abalone), viscera_weight (the gut), and shell_weight (the shell, after drying). The whole_weight is not exactly equal to the sum of these three weights, but it is very strongly correlated with them:\n\ndf[\"summed_weight (g)\"]  = df[\"shucked_weight (g)\"] + df[\"viscera_weight (g)\"] + df[\"shell_weight (g)\"]\nsns.scatterplot(data=df, \n                x='whole_weight (g)', \n                y='summed_weight (g)', \n                alpha = 0.2)\n\n\n\n\n\n\n\nFigure 3.7: Strong correlation (linear trend) between whole weight and the sum of shucked, viscera, and shell weights.\n\n\n\n\n\nLet’s therefore drop the whole_weight column to avoid redundancy:\n\ndf.drop(columns=[\"whole_weight (g)\"], axis=1, inplace=True)\n\nNow we can try building linear regression models to predict rings in terms of the other features. Here’s an example of doing this by hand: we’ll try out the model\n\\[\n\\begin{aligned}\n    \\text{rings} \\approx  15 \\times \\text{diameter} + 4 \\times \\text{shucked weight} + 1.5\n\\end{aligned}\n\\]\n\nw_1_guess = 15\nw_2_guess = 4\nb_guess = 1.5\n\ndf['rings_pred'] = w_1_guess * df['diameter (mm)'] + w_2_guess * df['shucked_weight (g)'] + b_guess\n\nmse_value = mse(df['rings'], df['rings_pred'])\n\nThis model has an MSE of mse_value=2.5e+06. Now that we’re done with the rings_pred column, let’s drop it and the summed_weight column we created earlier:\n\ndf.drop(columns=['rings_pred', 'summed_weight (g)'], inplace=True)\n\nWe could imagine trying to loop through different values of the parameters to find a better model, but this would be cumbersome, especially if we wanted to use more than two features. To address this, we’ll introduce the idea of model training as an optimization problem, and take a look at the scikit-learn library for automating this process.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introducing Prediction</span>"
    ]
  },
  {
    "objectID": "chapters/20-introduction-prediction.html#sidebar-training-as-optimization",
    "href": "chapters/20-introduction-prediction.html#sidebar-training-as-optimization",
    "title": "3  Introducing Prediction",
    "section": "Sidebar: Training as Optimization",
    "text": "Sidebar: Training as Optimization\nA general version of a linear regression model with many features can be written as follows:\n\\[\n\\begin{aligned}\n    \\hat{y} = w_1 x_1 + w_2 x_2 + \\ldots + w_p x_p + b = \\sum_{j=1}^{p} w_j x_j + b\n\\end{aligned}\n\\]\nThe MSE for this model is given by\n\\[\n\\begin{aligned}\n    \\text{MSE}(w_1, w_2, \\ldots, w_p, b) = \\frac{1}{n} \\sum_{i=1}^{n} \\left( y_i - \\hat{y}_i \\right)^2 = \\frac{1}{n} \\sum_{i=1}^{n} \\left( y_i - \\left( \\sum_{j=1}^{p} w_j x_{ij} + b \\right) \\right)^2\\;.\n\\end{aligned}\n\\]\nTo train the model, we’ll choose parameters \\(w_1, w_2, \\ldots, w_p, b\\) to minimize the MSE; that is, we’ll find these parameters to make the MSE as small as possible. Formally, we often write this as\n\\[\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{aligned}\n    \\hat{w}_1, \\hat{w}_2,\\ldots, \\hat{w}_p, \\hat{b} = \\argmin_{w_1, w_2, \\ldots, w_p, b} \\text{MSE}(w_1, w_2, \\ldots, w_p, b)\\;.\n\\end{aligned}\n\\]\nThis is an optimization problem. The challenge of finding an optimal value for the parameters is a very rich one with many interesting solution algorithms. For our purposes in this class, we’ll take advantage of software packages which have already implemented these algorithms for us.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introducing Prediction</span>"
    ]
  },
  {
    "objectID": "chapters/20-introduction-prediction.html#scikit-learn-for-linear-regression",
    "href": "chapters/20-introduction-prediction.html#scikit-learn-for-linear-regression",
    "title": "3  Introducing Prediction",
    "section": "scikit-learn for Linear Regression",
    "text": "scikit-learn for Linear Regression\nThe scikit-learn package in Python, also called sklearn, is one such package.\n\nfrom sklearn.linear_model import LinearRegression\n\nWe’ll use this model to fit a linear regression model to predict rings from all the other features in the abalone data set. First, we need to convert the qualitative sex column into numerical columns using one-hot encoding:\n\ndf = pd.get_dummies(df, columns=['sex'], drop_first=True, dtype=int)\n\ndf.columns\n\nIndex(['length (mm)', 'diameter (mm)', 'height (mm)', 'shucked_weight (g)',\n       'viscera_weight (g)', 'shell_weight (g)', 'rings', 'sex_I', 'sex_M'],\n      dtype='object')\n\n\nNow instead of a single column for sex, we have two binary columns: sex_I and sex_M, indicating with a 1 whether the abalone is an infant or male. If both colummns are zero, then the abalone is female instead.\nThe scikit-learn API expects that we pass in a data frame X containing the features (inputs) and a series y containing the target (output). Let’s create these now:\n\nX = df.drop(columns=['rings'])\ny = df['rings']\n\nNow, finally, we are ready to fit the linear regression model. Finding the model that has the best values of the parameters is as simple as calling the fit method on a LinearRegression object:\n\nLR = LinearRegression()\nfit = LR.fit(X, y)\n\nWe can extract predictions for the model using the predict method:\n\ny_pred = LR.predict(X)\n\nOnce we have the predictions, we can also extract the MSE for the model:\n\nmse(y, y_pred)\n\nnp.float64(4.979110080607066)\n\n\nThis MSE is considerably smaller than the MSE we made with our by-hand model earlier!\nIt can also be helpful to look at the coefficients that the model learned for each feature:\n\npd.DataFrame({\n    'feature': LR.feature_names_in_,\n    'coefficient': LR.coef_\n}).sort_values(by='coefficient', ascending=False)\n\n\n\n\n\n\n\n\nfeature\ncoefficient\n\n\n\n\n5\nshell_weight (g)\n0.099027\n\n\n1\ndiameter (mm)\n0.058149\n\n\n2\nheight (mm)\n0.055457\n\n\n7\nsex_M\n0.051251\n\n\n0\nlength (mm)\n-0.003549\n\n\n4\nviscera_weight (g)\n-0.003759\n\n\n3\nshucked_weight (g)\n-0.057041\n\n\n6\nsex_I\n-0.872555\n\n\n\n\n\n\n\nThese coefficients can be quite helpful, although the interpretation is often subtle. It’s tempting to believe that larger coefficients mean that a given feature is “more important” for predicting the target, but things are not usually this simple. For example, notice that two of the weight features actually have negative coefficients, suggesting, for example, that a larger value of shucked_weight (g) should correspond to a younger abalone! This comes from the fact that shucked_weight is strongly correlated with shell_weight (g) and viscera_weight (g). This phenomenon, called multicollinearity in the statistics literature, can make interpreting coefficients quite tricky. We’ll revisit this issue later in the course. In the context of prediction, it’s often not necessary to interpret these coefficients at all.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introducing Prediction</span>"
    ]
  },
  {
    "objectID": "chapters/20-introduction-prediction.html#references",
    "href": "chapters/20-introduction-prediction.html#references",
    "title": "3  Introducing Prediction",
    "section": "References",
    "text": "References\n\n\n\n\nNash, Sellers, Warwick, and Wes Ford. 1994. “Abalone.” UCI Machine Learning Repository.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introducing Prediction</span>"
    ]
  }
]